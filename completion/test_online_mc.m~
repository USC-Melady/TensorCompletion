clear; clc;
sz = [100, 100];
X = rand(sz);

n = prod(sz); % total number of entries
m = 3; % total number of blocks
k = ceil(n * 0.8);


% simulate observed entries
A = eye(10);
B = ones(5);
tmp = kron(A,B) ;
Omega = zeros(sz);

% non-overlapping
Omega(1:50,51:end) = tmp;
Omega(51:end, 1:50)= tmp;

%% 
r = 5;
v = [];
while( length(v)~= length(Omega) )
    degree = sum(Omega);
    v = find(degree >= r );
    Omega = Omega( v, v);
end


%%
graph = sparse(Omega);
% find strongly-connected component
[K,C] = graphconncomp(graph);

%%
% set parameters
n1 = sz(1);
n2 = sz(2);

df = r*(n1+n2-r);
oversampling = 5; 
m = min(5*df,round(.99*n1*n2) ); 
p  = m/(n1*n2);

tau = 5*sqrt(n1*n2); 
delta = 1.2/p; 
data = X.*Omega;
%{
 if n1 and n2 are very different, then
   tau should probably be bigger than 5*sqrt(n1*n2)

 increase tau to increase accuracy; decrease it for speed

 if the algorithm doesn't work well, try changing tau and delta
   i.e. if it diverges, try a smaller delta (e.g. delta < 2 is a 
   safe choice, but the algorithm may be slower than necessary).
%}
maxiter = 500; 
tol = 1e-4;


for i = 1:K
    blk_idx = find(C==i);
    sz_blk = [length(blk_idx),length(blk_idx)];
    Omega_i = sub2ind(Omega(blk_idx, blk_idx), size();
    % solve svt for each block
    [U,S,V,numiter] = SVT(sz_blk,Omega_i,data,tau,delta,maxiter,tol);
    X_i = U*S*V';

end